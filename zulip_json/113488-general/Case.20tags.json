[
    {
        "content": "<p>I'm currently trying to understand how case tags work, and they are rather more complicated than expected. There seem to be two ways to tag a goal as a 'case', <code>_case.n</code> (where <code>n</code> is a natural number; what's this for?) and <code>_case_simple</code>. Both seem to be in use. When the <code>case</code> tactic tries to find a case that matches the name given by the user, it inspects the term constructed so far <a href=\"https://github.com/leanprover-community/lean/blob/c59125c188468fb83ca95353376e1ce953b57a5e/library/init/meta/interactive.lean#L629\" title=\"https://github.com/leanprover-community/lean/blob/c59125c188468fb83ca95353376e1ce953b57a5e/library/init/meta/interactive.lean#L629\">in some unholy fashion</a> -- but only for <code>_case_simple</code> tags. Does anyone know why all this is necessary? I would have expected <code>case</code> to just look for a goal with a matching name.</p>",
        "id": 194832958,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1587488894
    },
    {
        "content": "<p>The \"interesting\" code is from my original implementation of <code>case</code>, before Leo added any tag management. As the comment at the use site of <code>find_case</code> explains, it is not being used for actually locating the goal anymore. I don't know/remember much about the tags themselves.</p>",
        "id": 194857600,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1587501142
    },
    {
        "content": "<p>Thanks, that helps a lot! Perhaps a refactoring to remove <code>_case_simple</code> is in order.</p>",
        "id": 194937444,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1587565096
    },
    {
        "content": "<p>I think I broadly understand what's happening now. Documenting it here (for myself if noone else):</p>\n<ul>\n<li>A tag is a list of names.</li>\n<li><code>induction</code> and <code>cases</code> (and variants) tag each goal they generate with the tag <code>['_case_simple, cname]</code> where <code>cname</code> is the name of the constructor (fully qualified).</li>\n<li><code>with_cases t</code> runs the tactic <code>t</code>. Then, for any new goal <code>g</code> produced by <code>t</code>, it reverts any hypotheses of <code>g</code> that did not occur in the original goal. Finally, <code>g</code>'s tag gets prefixed with <code>'_case.n</code> where <code>n</code> is the number of hypotheses that were reverted.</li>\n<li><code>case name : x, y, ...</code> first finds a goal whose tag matches <code>name</code>. It then proceeds according to whether the goal's tag starts with <code>'_case.n</code> or <code>'_case_simple</code>.<ul>\n<li>For <code>'_case.n</code>, it introduces <code>n</code> arguments, using the names <code>x, y, ...</code> (if available).</li>\n<li>For <code>'_case_simple</code>, it determines the number of arguments of the constructor which generated this case. (This is what the linked <code>find_case</code> does, as far as I can tell.) It then renames these arguments to <code>x, y, ...</code> (if available).</li>\n</ul>\n</li>\n</ul>",
        "id": 194949985,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1587570017
    },
    {
        "content": "<p>A PR to add this info in the form of doc strings to leanprover-community/lean would be greatly appreciated!</p>",
        "id": 194950171,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1587570103
    },
    {
        "content": "<p>Can do, but at the moment I want to redesign the whole thing anyway. Besides being ugly, the <code>find_case</code> hack leads to such tight coupling between <code>induction</code>/<code>cases</code> and <code>case</code> that I can't use case tags with an alternative induction tactic that I'm working on.</p>",
        "id": 194951189,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1587570569
    },
    {
        "content": "<p>New design:</p>\n<ul>\n<li>A case tag has the form <code>['_case, cname_0, ... cname_m, '_arg.x_0, ..., '_arg.x_n, '_end_case]</code> where the <code>cname_i</code> are names associated with the case (usually just one constructor name) and the <code>x_i</code> are the unique names of those local hypotheses which were added for the case.</li>\n<li><code>cases</code>, <code>induction</code> and friends, when called on a goal with tag <code>t</code>, generate one goal per constructor and prepend an appropriate case tag to <code>t</code>.</li>\n<li><code>case c : x y z... { t }</code> searches all goals for one whose tag includes a case tag for <code>c</code>. (The search remains fuzzy, so <code>case zero</code> finds a goal tagged <code>nat.zero</code>.) If it finds exactly one such goal, it renames the <code>_arg</code> hypotheses to <code>x, y, z, ...</code> (if present) and runs <code>t</code> on the goal.</li>\n<li>Some other tactics can also set tags if tags are enabled. As far as I can tell, these are always 'simple' tags, meaning the tag is just one or more names which are associated with the case. For example, <code>apply</code> can set tags for generated subgoals if the arguments that generate these subgoals are named in the applied lemma.</li>\n<li><code>with_cases t</code> runs <code>t</code> with tags enabled. For each new goal <code>g</code>, it then generates a case tag <code>['_case, cname_i, ..., '_arg.x_i, ..., '_end_case]</code> where<ul>\n<li>the <code>cname_i</code> are the associated names of any case tags or simple tags of <code>g</code>;</li>\n<li>the <code>_arg.x_i</code> are those hypotheses of <code>g</code> that did not appear in the original goal.<br>\nThis ensures that <code>with_cases</code> can be used both with <code>cases</code>/<code>induction</code> (though there isn't really any reason to do so any more) and with tactics like <code>apply</code> that generate simple tags. The latter is used occasionally in core, to apply custom induction principles.</li>\n</ul>\n</li>\n</ul>\n<p>This design should cover all current uses of case tags. It doesn't require any C++ changes. It is backwards-incompatible for people setting tags manually, but as far as I can see, there is only direct  use of <code>set_tag</code> in all of Github (the <code>wlog</code> tactic in mathlib, which I can fix).</p>\n<p>Any concerns?</p>",
        "id": 195007477,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1587601880
    },
    {
        "content": "<p>I don't like all this layered information in a <code>list name</code>. Why not just use an <code>expr</code>?</p>",
        "id": 195008268,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587602574
    },
    {
        "content": "<p>I'd also prefer more structured data. However, that would require changes to the C++ (tags are part of the tactic state), which I'd rather avoid.</p>",
        "id": 195012742,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1587608392
    },
    {
        "content": "<p>I don't think the C++ needs to do much? Just associate an expr to the goal instead of a list name. I don't think these tags are used much on the C++ side</p>",
        "id": 195016054,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587613733
    }
]